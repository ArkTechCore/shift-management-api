from __future__ import annotations

from datetime import datetime, date
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.core.deps import get_db, get_current_user
from app.models.user import User
from app.models.store import Store
from app.models.week import Week
from app.models.timeentry import TimeEntry
from app.models.membership import StoreMembership
from app.models.payroll_invoice import PayrollInvoice
from app.schemas.payroll_invoice import PayrollInvoiceOut, GenerateInvoicesResult

router = APIRouter()


def _role(me: User) -> str:
    return (getattr(me, "role", "") or "").lower()


def _require_tenant(me: User):
    if getattr(me, "tenant_id", None) is None:
        raise HTTPException(status_code=403, detail="Tenant context missing.")


def _require_manager_or_admin(me: User):
    if _role(me) not in ["tenant_admin", "manager"]:
        raise HTTPException(status_code=403, detail="Manager/Admin access required.")


def _parse_week_start(week_start: str) -> date:
    try:
        return datetime.strptime(week_start, "%Y-%m-%d").date()
    except Exception:
        raise HTTPException(status_code=400, detail="week_start must be YYYY-MM-DD")


def _minutes_between(ci: datetime, co: datetime | None) -> int:
    if not ci or not co:
        return 0
    sec = int((co - ci).total_seconds())
    if sec <= 0:
        return 0
    return sec // 60


def _safe_float(v, default=0.0) -> float:
    try:
        if v is None:
            return float(default)
        return float(str(v).strip())
    except Exception:
        return float(default)


@router.post(
    "/stores/{store_id}/week/{week_start}/generate-invoices",
    response_model=GenerateInvoicesResult,
)
def generate_store_week_invoices(
    store_id: str,
    week_start: str,
    db: Session = Depends(get_db),
    me: User = Depends(get_current_user),
):
    _require_tenant(me)
    _require_manager_or_admin(me)

    ws = _parse_week_start(week_start)

    store = (
        db.query(Store)
        .filter(Store.id == store_id, Store.tenant_id == me.tenant_id)
        .first()
    )
    if not store:
        raise HTTPException(status_code=404, detail="Store not found.")

    wk = db.query(Week).filter(Week.week_start == ws).first()
    if not wk:
        raise HTTPException(status_code=404, detail="Week not found for that week_start.")

    entries = (
        db.query(TimeEntry)
        .filter(TimeEntry.store_id == store_id, TimeEntry.week_id == wk.id)
        .all()
    )

    minutes_by_emp: dict[str, int] = {}
    for e in entries:
        m = _minutes_between(e.clock_in_at, e.clock_out_at)
        if m <= 0:
            continue
        emp_id = str(e.employee_id)
        minutes_by_emp[emp_id] = minutes_by_emp.get(emp_id, 0) + m

    if not minutes_by_emp:
        return GenerateInvoicesResult(created=0, skipped_existing=0)

    created = 0
    skipped = 0

    for emp_id_str, total_minutes in minutes_by_emp.items():
        exists = (
            db.query(PayrollInvoice)
            .filter(
                PayrollInvoice.store_id == store_id,
                PayrollInvoice.employee_id == emp_id_str,
                PayrollInvoice.week_start == ws,
            )
            .first()
        )
        if exists:
            skipped += 1
            continue

        mem = (
            db.query(StoreMembership)
            .filter(
                StoreMembership.store_id == store_id,
                StoreMembership.user_id == emp_id_str,
                StoreMembership.is_active == True,  # noqa: E712
            )
            .first()
        )

        pay_rate = _safe_float(getattr(mem, "pay_rate_hourly", None), 0.0)
        if pay_rate <= 0:
            pay_rate = _safe_float(getattr(mem, "pay_rate", None), 0.0)

        tax_enabled = bool(getattr(mem, "tax_enabled", False))
        tax_rate_percent = _safe_float(getattr(mem, "tax_rate_percent", None), 0.0)

        total_hours = total_minutes / 60.0
        regular_hours = min(total_hours, 40.0)
        overtime_hours = max(total_hours - 40.0, 0.0)

        gross = (regular_hours * pay_rate) + (overtime_hours * pay_rate * 1.5)

        tax_withheld = 0.0
        if tax_enabled and tax_rate_percent > 0:
            tax_withheld = gross * (tax_rate_percent / 100.0)

        net = gross - tax_withheld

        inv = PayrollInvoice(
            tenant_id=me.tenant_id,
            store_id=store_id,
            employee_id=emp_id_str,
            week_start=ws,
            # invoice_no is generated by DB sequence automatically âœ…
            pay_rate_hourly=pay_rate,
            regular_minutes=int(regular_hours * 60),
            overtime_minutes=int(overtime_hours * 60),
            gross_pay=round(gross, 2),
            tax_enabled=tax_enabled,
            tax_rate_percent=tax_rate_percent,
            tax_withheld=round(tax_withheld, 2),
            net_pay=round(net, 2),
            status="issued",
        )

        db.add(inv)
        created += 1

    db.commit()

    return GenerateInvoicesResult(created=created, skipped_existing=skipped)


@router.get(
    "/stores/{store_id}/week/{week_start}/invoices",
    response_model=list[PayrollInvoiceOut],
)
def list_store_week_invoices(
    store_id: str,
    week_start: str,
    db: Session = Depends(get_db),
    me: User = Depends(get_current_user),
):
    _require_tenant(me)
    _require_manager_or_admin(me)

    ws = _parse_week_start(week_start)

    store = (
        db.query(Store)
        .filter(Store.id == store_id, Store.tenant_id == me.tenant_id)
        .first()
    )
    if not store:
        raise HTTPException(status_code=404, detail="Store not found.")

    return (
        db.query(PayrollInvoice)
        .filter(
            PayrollInvoice.tenant_id == me.tenant_id,
            PayrollInvoice.store_id == store_id,
            PayrollInvoice.week_start == ws,
        )
        .order_by(PayrollInvoice.invoice_no.asc())
        .all()
    )


@router.get("/me/week/{week_start}/invoices", response_model=list[PayrollInvoiceOut])
def list_my_week_invoices(
    week_start: str,
    db: Session = Depends(get_db),
    me: User = Depends(get_current_user),
):
    _require_tenant(me)

    ws = _parse_week_start(week_start)

    return (
        db.query(PayrollInvoice)
        .filter(
            PayrollInvoice.tenant_id == me.tenant_id,
            PayrollInvoice.employee_id == str(me.id),
            PayrollInvoice.week_start == ws,
        )
        .order_by(PayrollInvoice.invoice_no.asc())
        .all()
    )


@router.get("/invoices/{invoice_id}", response_model=PayrollInvoiceOut)
def get_invoice(
    invoice_id: str,
    db: Session = Depends(get_db),
    me: User = Depends(get_current_user),
):
    _require_tenant(me)

    inv = (
        db.query(PayrollInvoice)
        .filter(PayrollInvoice.id == invoice_id, PayrollInvoice.tenant_id == me.tenant_id)
        .first()
    )
    if not inv:
        raise HTTPException(status_code=404, detail="Invoice not found.")

    if _role(me) == "employee" and str(inv.employee_id) != str(me.id):
        raise HTTPException(status_code=403, detail="Not allowed.")

    return inv
